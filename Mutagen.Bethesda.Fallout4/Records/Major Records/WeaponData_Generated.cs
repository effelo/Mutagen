/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Internals;
using Mutagen.Bethesda.Fallout4.Internals;
using Noggog;
using System;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Text;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class WeaponData :
        IWeaponData,
        ILoquiObjectSetter<WeaponData>,
        IEquatable<IWeaponDataGetter>
    {
        #region Ctor
        public WeaponData()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region AnimationType
        public WeaponAnimationType AnimationType { get; set; } = default;
        #endregion
        #region Unused
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private MemorySlice<Byte> _Unused = new byte[3];
        public MemorySlice<Byte> Unused
        {
            get => _Unused;
            set => this._Unused = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IWeaponDataGetter.Unused => this.Unused;
        #endregion
        #region Speed
        public Single Speed { get; set; } = default;
        #endregion
        #region Reach
        public Single Reach { get; set; } = default;
        #endregion
        #region Flags
        public WeaponData.Flag Flags { get; set; } = default;
        #endregion
        #region Unused2
        public Int16 Unused2 { get; set; } = default;
        #endregion
        #region SightFOV
        public Single SightFOV { get; set; } = default;
        #endregion
        #region Unknown
        public Int32 Unknown { get; set; } = default;
        #endregion
        #region BaseVATStoHitChance
        public Byte BaseVATStoHitChance { get; set; } = default;
        #endregion
        #region AttackAnimation
        public readonly static WeaponData.AttackAnimationType _AttackAnimation_Default = WeaponData.AttackAnimationType.Default;
        public WeaponData.AttackAnimationType AttackAnimation { get; set; } = _AttackAnimation_Default;
        #endregion
        #region NumProjectiles
        public Byte NumProjectiles { get; set; } = default;
        #endregion
        #region EmbeddedWeaponAV
        public Byte EmbeddedWeaponAV { get; set; } = default;
        #endregion
        #region RangeMin
        public Single RangeMin { get; set; } = default;
        #endregion
        #region RangeMax
        public Single RangeMax { get; set; } = default;
        #endregion
        #region OnHit
        public WeaponData.OnHitType OnHit { get; set; } = default;
        #endregion
        #region AnimationAttackMult
        public Single AnimationAttackMult { get; set; } = default;
        #endregion
        #region Unknown2
        public Int32 Unknown2 { get; set; } = default;
        #endregion
        #region RumbleLeftMotorStrength
        public Single RumbleLeftMotorStrength { get; set; } = default;
        #endregion
        #region RumbleRightMotorStrength
        public Single RumbleRightMotorStrength { get; set; } = default;
        #endregion
        #region RumbleDuration
        public Single RumbleDuration { get; set; } = default;
        #endregion
        #region Unknown3
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private MemorySlice<Byte> _Unknown3 = new byte[12];
        public MemorySlice<Byte> Unknown3
        {
            get => _Unknown3;
            set => this._Unknown3 = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IWeaponDataGetter.Unknown3 => this.Unknown3;
        #endregion
        #region Skill
        public Skill? Skill { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Skill? IWeaponDataGetter.Skill => this.Skill;
        #endregion
        #region Unknown4
        public Int64 Unknown4 { get; set; } = default;
        #endregion
        #region Resist
        public readonly static ActorValue _Resist_Default = ActorValue.None;
        public ActorValue Resist { get; set; } = _Resist_Default;
        #endregion
        #region Unknown5
        public Int32 Unknown5 { get; set; } = default;
        #endregion
        #region Stagger
        public Single Stagger { get; set; } = default;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            WeaponDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IWeaponDataGetter rhs)) return false;
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(IWeaponDataGetter? obj)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.AnimationType = initialValue;
                this.Unused = initialValue;
                this.Speed = initialValue;
                this.Reach = initialValue;
                this.Flags = initialValue;
                this.Unused2 = initialValue;
                this.SightFOV = initialValue;
                this.Unknown = initialValue;
                this.BaseVATStoHitChance = initialValue;
                this.AttackAnimation = initialValue;
                this.NumProjectiles = initialValue;
                this.EmbeddedWeaponAV = initialValue;
                this.RangeMin = initialValue;
                this.RangeMax = initialValue;
                this.OnHit = initialValue;
                this.AnimationAttackMult = initialValue;
                this.Unknown2 = initialValue;
                this.RumbleLeftMotorStrength = initialValue;
                this.RumbleRightMotorStrength = initialValue;
                this.RumbleDuration = initialValue;
                this.Unknown3 = initialValue;
                this.Skill = initialValue;
                this.Unknown4 = initialValue;
                this.Resist = initialValue;
                this.Unknown5 = initialValue;
                this.Stagger = initialValue;
            }

            public Mask(
                TItem AnimationType,
                TItem Unused,
                TItem Speed,
                TItem Reach,
                TItem Flags,
                TItem Unused2,
                TItem SightFOV,
                TItem Unknown,
                TItem BaseVATStoHitChance,
                TItem AttackAnimation,
                TItem NumProjectiles,
                TItem EmbeddedWeaponAV,
                TItem RangeMin,
                TItem RangeMax,
                TItem OnHit,
                TItem AnimationAttackMult,
                TItem Unknown2,
                TItem RumbleLeftMotorStrength,
                TItem RumbleRightMotorStrength,
                TItem RumbleDuration,
                TItem Unknown3,
                TItem Skill,
                TItem Unknown4,
                TItem Resist,
                TItem Unknown5,
                TItem Stagger)
            {
                this.AnimationType = AnimationType;
                this.Unused = Unused;
                this.Speed = Speed;
                this.Reach = Reach;
                this.Flags = Flags;
                this.Unused2 = Unused2;
                this.SightFOV = SightFOV;
                this.Unknown = Unknown;
                this.BaseVATStoHitChance = BaseVATStoHitChance;
                this.AttackAnimation = AttackAnimation;
                this.NumProjectiles = NumProjectiles;
                this.EmbeddedWeaponAV = EmbeddedWeaponAV;
                this.RangeMin = RangeMin;
                this.RangeMax = RangeMax;
                this.OnHit = OnHit;
                this.AnimationAttackMult = AnimationAttackMult;
                this.Unknown2 = Unknown2;
                this.RumbleLeftMotorStrength = RumbleLeftMotorStrength;
                this.RumbleRightMotorStrength = RumbleRightMotorStrength;
                this.RumbleDuration = RumbleDuration;
                this.Unknown3 = Unknown3;
                this.Skill = Skill;
                this.Unknown4 = Unknown4;
                this.Resist = Resist;
                this.Unknown5 = Unknown5;
                this.Stagger = Stagger;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem AnimationType;
            public TItem Unused;
            public TItem Speed;
            public TItem Reach;
            public TItem Flags;
            public TItem Unused2;
            public TItem SightFOV;
            public TItem Unknown;
            public TItem BaseVATStoHitChance;
            public TItem AttackAnimation;
            public TItem NumProjectiles;
            public TItem EmbeddedWeaponAV;
            public TItem RangeMin;
            public TItem RangeMax;
            public TItem OnHit;
            public TItem AnimationAttackMult;
            public TItem Unknown2;
            public TItem RumbleLeftMotorStrength;
            public TItem RumbleRightMotorStrength;
            public TItem RumbleDuration;
            public TItem Unknown3;
            public TItem Skill;
            public TItem Unknown4;
            public TItem Resist;
            public TItem Unknown5;
            public TItem Stagger;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.AnimationType, rhs.AnimationType)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                if (!object.Equals(this.Speed, rhs.Speed)) return false;
                if (!object.Equals(this.Reach, rhs.Reach)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.Unused2, rhs.Unused2)) return false;
                if (!object.Equals(this.SightFOV, rhs.SightFOV)) return false;
                if (!object.Equals(this.Unknown, rhs.Unknown)) return false;
                if (!object.Equals(this.BaseVATStoHitChance, rhs.BaseVATStoHitChance)) return false;
                if (!object.Equals(this.AttackAnimation, rhs.AttackAnimation)) return false;
                if (!object.Equals(this.NumProjectiles, rhs.NumProjectiles)) return false;
                if (!object.Equals(this.EmbeddedWeaponAV, rhs.EmbeddedWeaponAV)) return false;
                if (!object.Equals(this.RangeMin, rhs.RangeMin)) return false;
                if (!object.Equals(this.RangeMax, rhs.RangeMax)) return false;
                if (!object.Equals(this.OnHit, rhs.OnHit)) return false;
                if (!object.Equals(this.AnimationAttackMult, rhs.AnimationAttackMult)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                if (!object.Equals(this.RumbleLeftMotorStrength, rhs.RumbleLeftMotorStrength)) return false;
                if (!object.Equals(this.RumbleRightMotorStrength, rhs.RumbleRightMotorStrength)) return false;
                if (!object.Equals(this.RumbleDuration, rhs.RumbleDuration)) return false;
                if (!object.Equals(this.Unknown3, rhs.Unknown3)) return false;
                if (!object.Equals(this.Skill, rhs.Skill)) return false;
                if (!object.Equals(this.Unknown4, rhs.Unknown4)) return false;
                if (!object.Equals(this.Resist, rhs.Resist)) return false;
                if (!object.Equals(this.Unknown5, rhs.Unknown5)) return false;
                if (!object.Equals(this.Stagger, rhs.Stagger)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.AnimationType);
                hash.Add(this.Unused);
                hash.Add(this.Speed);
                hash.Add(this.Reach);
                hash.Add(this.Flags);
                hash.Add(this.Unused2);
                hash.Add(this.SightFOV);
                hash.Add(this.Unknown);
                hash.Add(this.BaseVATStoHitChance);
                hash.Add(this.AttackAnimation);
                hash.Add(this.NumProjectiles);
                hash.Add(this.EmbeddedWeaponAV);
                hash.Add(this.RangeMin);
                hash.Add(this.RangeMax);
                hash.Add(this.OnHit);
                hash.Add(this.AnimationAttackMult);
                hash.Add(this.Unknown2);
                hash.Add(this.RumbleLeftMotorStrength);
                hash.Add(this.RumbleRightMotorStrength);
                hash.Add(this.RumbleDuration);
                hash.Add(this.Unknown3);
                hash.Add(this.Skill);
                hash.Add(this.Unknown4);
                hash.Add(this.Resist);
                hash.Add(this.Unknown5);
                hash.Add(this.Stagger);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.AnimationType)) return false;
                if (!eval(this.Unused)) return false;
                if (!eval(this.Speed)) return false;
                if (!eval(this.Reach)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.Unused2)) return false;
                if (!eval(this.SightFOV)) return false;
                if (!eval(this.Unknown)) return false;
                if (!eval(this.BaseVATStoHitChance)) return false;
                if (!eval(this.AttackAnimation)) return false;
                if (!eval(this.NumProjectiles)) return false;
                if (!eval(this.EmbeddedWeaponAV)) return false;
                if (!eval(this.RangeMin)) return false;
                if (!eval(this.RangeMax)) return false;
                if (!eval(this.OnHit)) return false;
                if (!eval(this.AnimationAttackMult)) return false;
                if (!eval(this.Unknown2)) return false;
                if (!eval(this.RumbleLeftMotorStrength)) return false;
                if (!eval(this.RumbleRightMotorStrength)) return false;
                if (!eval(this.RumbleDuration)) return false;
                if (!eval(this.Unknown3)) return false;
                if (!eval(this.Skill)) return false;
                if (!eval(this.Unknown4)) return false;
                if (!eval(this.Resist)) return false;
                if (!eval(this.Unknown5)) return false;
                if (!eval(this.Stagger)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.AnimationType)) return true;
                if (eval(this.Unused)) return true;
                if (eval(this.Speed)) return true;
                if (eval(this.Reach)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.Unused2)) return true;
                if (eval(this.SightFOV)) return true;
                if (eval(this.Unknown)) return true;
                if (eval(this.BaseVATStoHitChance)) return true;
                if (eval(this.AttackAnimation)) return true;
                if (eval(this.NumProjectiles)) return true;
                if (eval(this.EmbeddedWeaponAV)) return true;
                if (eval(this.RangeMin)) return true;
                if (eval(this.RangeMax)) return true;
                if (eval(this.OnHit)) return true;
                if (eval(this.AnimationAttackMult)) return true;
                if (eval(this.Unknown2)) return true;
                if (eval(this.RumbleLeftMotorStrength)) return true;
                if (eval(this.RumbleRightMotorStrength)) return true;
                if (eval(this.RumbleDuration)) return true;
                if (eval(this.Unknown3)) return true;
                if (eval(this.Skill)) return true;
                if (eval(this.Unknown4)) return true;
                if (eval(this.Resist)) return true;
                if (eval(this.Unknown5)) return true;
                if (eval(this.Stagger)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new WeaponData.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.AnimationType = eval(this.AnimationType);
                obj.Unused = eval(this.Unused);
                obj.Speed = eval(this.Speed);
                obj.Reach = eval(this.Reach);
                obj.Flags = eval(this.Flags);
                obj.Unused2 = eval(this.Unused2);
                obj.SightFOV = eval(this.SightFOV);
                obj.Unknown = eval(this.Unknown);
                obj.BaseVATStoHitChance = eval(this.BaseVATStoHitChance);
                obj.AttackAnimation = eval(this.AttackAnimation);
                obj.NumProjectiles = eval(this.NumProjectiles);
                obj.EmbeddedWeaponAV = eval(this.EmbeddedWeaponAV);
                obj.RangeMin = eval(this.RangeMin);
                obj.RangeMax = eval(this.RangeMax);
                obj.OnHit = eval(this.OnHit);
                obj.AnimationAttackMult = eval(this.AnimationAttackMult);
                obj.Unknown2 = eval(this.Unknown2);
                obj.RumbleLeftMotorStrength = eval(this.RumbleLeftMotorStrength);
                obj.RumbleRightMotorStrength = eval(this.RumbleRightMotorStrength);
                obj.RumbleDuration = eval(this.RumbleDuration);
                obj.Unknown3 = eval(this.Unknown3);
                obj.Skill = eval(this.Skill);
                obj.Unknown4 = eval(this.Unknown4);
                obj.Resist = eval(this.Resist);
                obj.Unknown5 = eval(this.Unknown5);
                obj.Stagger = eval(this.Stagger);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(WeaponData.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, WeaponData.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(WeaponData.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.AnimationType ?? true)
                    {
                        fg.AppendItem(AnimationType, "AnimationType");
                    }
                    if (printMask?.Unused ?? true)
                    {
                        fg.AppendItem(Unused, "Unused");
                    }
                    if (printMask?.Speed ?? true)
                    {
                        fg.AppendItem(Speed, "Speed");
                    }
                    if (printMask?.Reach ?? true)
                    {
                        fg.AppendItem(Reach, "Reach");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.Unused2 ?? true)
                    {
                        fg.AppendItem(Unused2, "Unused2");
                    }
                    if (printMask?.SightFOV ?? true)
                    {
                        fg.AppendItem(SightFOV, "SightFOV");
                    }
                    if (printMask?.Unknown ?? true)
                    {
                        fg.AppendItem(Unknown, "Unknown");
                    }
                    if (printMask?.BaseVATStoHitChance ?? true)
                    {
                        fg.AppendItem(BaseVATStoHitChance, "BaseVATStoHitChance");
                    }
                    if (printMask?.AttackAnimation ?? true)
                    {
                        fg.AppendItem(AttackAnimation, "AttackAnimation");
                    }
                    if (printMask?.NumProjectiles ?? true)
                    {
                        fg.AppendItem(NumProjectiles, "NumProjectiles");
                    }
                    if (printMask?.EmbeddedWeaponAV ?? true)
                    {
                        fg.AppendItem(EmbeddedWeaponAV, "EmbeddedWeaponAV");
                    }
                    if (printMask?.RangeMin ?? true)
                    {
                        fg.AppendItem(RangeMin, "RangeMin");
                    }
                    if (printMask?.RangeMax ?? true)
                    {
                        fg.AppendItem(RangeMax, "RangeMax");
                    }
                    if (printMask?.OnHit ?? true)
                    {
                        fg.AppendItem(OnHit, "OnHit");
                    }
                    if (printMask?.AnimationAttackMult ?? true)
                    {
                        fg.AppendItem(AnimationAttackMult, "AnimationAttackMult");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        fg.AppendItem(Unknown2, "Unknown2");
                    }
                    if (printMask?.RumbleLeftMotorStrength ?? true)
                    {
                        fg.AppendItem(RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
                    }
                    if (printMask?.RumbleRightMotorStrength ?? true)
                    {
                        fg.AppendItem(RumbleRightMotorStrength, "RumbleRightMotorStrength");
                    }
                    if (printMask?.RumbleDuration ?? true)
                    {
                        fg.AppendItem(RumbleDuration, "RumbleDuration");
                    }
                    if (printMask?.Unknown3 ?? true)
                    {
                        fg.AppendItem(Unknown3, "Unknown3");
                    }
                    if (printMask?.Skill ?? true)
                    {
                        fg.AppendItem(Skill, "Skill");
                    }
                    if (printMask?.Unknown4 ?? true)
                    {
                        fg.AppendItem(Unknown4, "Unknown4");
                    }
                    if (printMask?.Resist ?? true)
                    {
                        fg.AppendItem(Resist, "Resist");
                    }
                    if (printMask?.Unknown5 ?? true)
                    {
                        fg.AppendItem(Unknown5, "Unknown5");
                    }
                    if (printMask?.Stagger ?? true)
                    {
                        fg.AppendItem(Stagger, "Stagger");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? AnimationType;
            public Exception? Unused;
            public Exception? Speed;
            public Exception? Reach;
            public Exception? Flags;
            public Exception? Unused2;
            public Exception? SightFOV;
            public Exception? Unknown;
            public Exception? BaseVATStoHitChance;
            public Exception? AttackAnimation;
            public Exception? NumProjectiles;
            public Exception? EmbeddedWeaponAV;
            public Exception? RangeMin;
            public Exception? RangeMax;
            public Exception? OnHit;
            public Exception? AnimationAttackMult;
            public Exception? Unknown2;
            public Exception? RumbleLeftMotorStrength;
            public Exception? RumbleRightMotorStrength;
            public Exception? RumbleDuration;
            public Exception? Unknown3;
            public Exception? Skill;
            public Exception? Unknown4;
            public Exception? Resist;
            public Exception? Unknown5;
            public Exception? Stagger;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        return AnimationType;
                    case WeaponData_FieldIndex.Unused:
                        return Unused;
                    case WeaponData_FieldIndex.Speed:
                        return Speed;
                    case WeaponData_FieldIndex.Reach:
                        return Reach;
                    case WeaponData_FieldIndex.Flags:
                        return Flags;
                    case WeaponData_FieldIndex.Unused2:
                        return Unused2;
                    case WeaponData_FieldIndex.SightFOV:
                        return SightFOV;
                    case WeaponData_FieldIndex.Unknown:
                        return Unknown;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        return BaseVATStoHitChance;
                    case WeaponData_FieldIndex.AttackAnimation:
                        return AttackAnimation;
                    case WeaponData_FieldIndex.NumProjectiles:
                        return NumProjectiles;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        return EmbeddedWeaponAV;
                    case WeaponData_FieldIndex.RangeMin:
                        return RangeMin;
                    case WeaponData_FieldIndex.RangeMax:
                        return RangeMax;
                    case WeaponData_FieldIndex.OnHit:
                        return OnHit;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        return AnimationAttackMult;
                    case WeaponData_FieldIndex.Unknown2:
                        return Unknown2;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        return RumbleLeftMotorStrength;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        return RumbleRightMotorStrength;
                    case WeaponData_FieldIndex.RumbleDuration:
                        return RumbleDuration;
                    case WeaponData_FieldIndex.Unknown3:
                        return Unknown3;
                    case WeaponData_FieldIndex.Skill:
                        return Skill;
                    case WeaponData_FieldIndex.Unknown4:
                        return Unknown4;
                    case WeaponData_FieldIndex.Resist:
                        return Resist;
                    case WeaponData_FieldIndex.Unknown5:
                        return Unknown5;
                    case WeaponData_FieldIndex.Stagger:
                        return Stagger;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        this.AnimationType = ex;
                        break;
                    case WeaponData_FieldIndex.Unused:
                        this.Unused = ex;
                        break;
                    case WeaponData_FieldIndex.Speed:
                        this.Speed = ex;
                        break;
                    case WeaponData_FieldIndex.Reach:
                        this.Reach = ex;
                        break;
                    case WeaponData_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case WeaponData_FieldIndex.Unused2:
                        this.Unused2 = ex;
                        break;
                    case WeaponData_FieldIndex.SightFOV:
                        this.SightFOV = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown:
                        this.Unknown = ex;
                        break;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        this.BaseVATStoHitChance = ex;
                        break;
                    case WeaponData_FieldIndex.AttackAnimation:
                        this.AttackAnimation = ex;
                        break;
                    case WeaponData_FieldIndex.NumProjectiles:
                        this.NumProjectiles = ex;
                        break;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        this.EmbeddedWeaponAV = ex;
                        break;
                    case WeaponData_FieldIndex.RangeMin:
                        this.RangeMin = ex;
                        break;
                    case WeaponData_FieldIndex.RangeMax:
                        this.RangeMax = ex;
                        break;
                    case WeaponData_FieldIndex.OnHit:
                        this.OnHit = ex;
                        break;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        this.AnimationAttackMult = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        this.RumbleLeftMotorStrength = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        this.RumbleRightMotorStrength = ex;
                        break;
                    case WeaponData_FieldIndex.RumbleDuration:
                        this.RumbleDuration = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown3:
                        this.Unknown3 = ex;
                        break;
                    case WeaponData_FieldIndex.Skill:
                        this.Skill = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown4:
                        this.Unknown4 = ex;
                        break;
                    case WeaponData_FieldIndex.Resist:
                        this.Resist = ex;
                        break;
                    case WeaponData_FieldIndex.Unknown5:
                        this.Unknown5 = ex;
                        break;
                    case WeaponData_FieldIndex.Stagger:
                        this.Stagger = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                WeaponData_FieldIndex enu = (WeaponData_FieldIndex)index;
                switch (enu)
                {
                    case WeaponData_FieldIndex.AnimationType:
                        this.AnimationType = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unused:
                        this.Unused = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Speed:
                        this.Speed = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Reach:
                        this.Reach = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unused2:
                        this.Unused2 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.SightFOV:
                        this.SightFOV = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown:
                        this.Unknown = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.BaseVATStoHitChance:
                        this.BaseVATStoHitChance = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.AttackAnimation:
                        this.AttackAnimation = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.NumProjectiles:
                        this.NumProjectiles = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.EmbeddedWeaponAV:
                        this.EmbeddedWeaponAV = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RangeMin:
                        this.RangeMin = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RangeMax:
                        this.RangeMax = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.OnHit:
                        this.OnHit = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.AnimationAttackMult:
                        this.AnimationAttackMult = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleLeftMotorStrength:
                        this.RumbleLeftMotorStrength = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleRightMotorStrength:
                        this.RumbleRightMotorStrength = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.RumbleDuration:
                        this.RumbleDuration = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown3:
                        this.Unknown3 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Skill:
                        this.Skill = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown4:
                        this.Unknown4 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Resist:
                        this.Resist = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Unknown5:
                        this.Unknown5 = (Exception?)obj;
                        break;
                    case WeaponData_FieldIndex.Stagger:
                        this.Stagger = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (AnimationType != null) return true;
                if (Unused != null) return true;
                if (Speed != null) return true;
                if (Reach != null) return true;
                if (Flags != null) return true;
                if (Unused2 != null) return true;
                if (SightFOV != null) return true;
                if (Unknown != null) return true;
                if (BaseVATStoHitChance != null) return true;
                if (AttackAnimation != null) return true;
                if (NumProjectiles != null) return true;
                if (EmbeddedWeaponAV != null) return true;
                if (RangeMin != null) return true;
                if (RangeMax != null) return true;
                if (OnHit != null) return true;
                if (AnimationAttackMult != null) return true;
                if (Unknown2 != null) return true;
                if (RumbleLeftMotorStrength != null) return true;
                if (RumbleRightMotorStrength != null) return true;
                if (RumbleDuration != null) return true;
                if (Unknown3 != null) return true;
                if (Skill != null) return true;
                if (Unknown4 != null) return true;
                if (Resist != null) return true;
                if (Unknown5 != null) return true;
                if (Stagger != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(AnimationType, "AnimationType");
                fg.AppendItem(Unused, "Unused");
                fg.AppendItem(Speed, "Speed");
                fg.AppendItem(Reach, "Reach");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(Unused2, "Unused2");
                fg.AppendItem(SightFOV, "SightFOV");
                fg.AppendItem(Unknown, "Unknown");
                fg.AppendItem(BaseVATStoHitChance, "BaseVATStoHitChance");
                fg.AppendItem(AttackAnimation, "AttackAnimation");
                fg.AppendItem(NumProjectiles, "NumProjectiles");
                fg.AppendItem(EmbeddedWeaponAV, "EmbeddedWeaponAV");
                fg.AppendItem(RangeMin, "RangeMin");
                fg.AppendItem(RangeMax, "RangeMax");
                fg.AppendItem(OnHit, "OnHit");
                fg.AppendItem(AnimationAttackMult, "AnimationAttackMult");
                fg.AppendItem(Unknown2, "Unknown2");
                fg.AppendItem(RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
                fg.AppendItem(RumbleRightMotorStrength, "RumbleRightMotorStrength");
                fg.AppendItem(RumbleDuration, "RumbleDuration");
                fg.AppendItem(Unknown3, "Unknown3");
                fg.AppendItem(Skill, "Skill");
                fg.AppendItem(Unknown4, "Unknown4");
                fg.AppendItem(Resist, "Resist");
                fg.AppendItem(Unknown5, "Unknown5");
                fg.AppendItem(Stagger, "Stagger");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.AnimationType = this.AnimationType.Combine(rhs.AnimationType);
                ret.Unused = this.Unused.Combine(rhs.Unused);
                ret.Speed = this.Speed.Combine(rhs.Speed);
                ret.Reach = this.Reach.Combine(rhs.Reach);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.Unused2 = this.Unused2.Combine(rhs.Unused2);
                ret.SightFOV = this.SightFOV.Combine(rhs.SightFOV);
                ret.Unknown = this.Unknown.Combine(rhs.Unknown);
                ret.BaseVATStoHitChance = this.BaseVATStoHitChance.Combine(rhs.BaseVATStoHitChance);
                ret.AttackAnimation = this.AttackAnimation.Combine(rhs.AttackAnimation);
                ret.NumProjectiles = this.NumProjectiles.Combine(rhs.NumProjectiles);
                ret.EmbeddedWeaponAV = this.EmbeddedWeaponAV.Combine(rhs.EmbeddedWeaponAV);
                ret.RangeMin = this.RangeMin.Combine(rhs.RangeMin);
                ret.RangeMax = this.RangeMax.Combine(rhs.RangeMax);
                ret.OnHit = this.OnHit.Combine(rhs.OnHit);
                ret.AnimationAttackMult = this.AnimationAttackMult.Combine(rhs.AnimationAttackMult);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                ret.RumbleLeftMotorStrength = this.RumbleLeftMotorStrength.Combine(rhs.RumbleLeftMotorStrength);
                ret.RumbleRightMotorStrength = this.RumbleRightMotorStrength.Combine(rhs.RumbleRightMotorStrength);
                ret.RumbleDuration = this.RumbleDuration.Combine(rhs.RumbleDuration);
                ret.Unknown3 = this.Unknown3.Combine(rhs.Unknown3);
                ret.Skill = this.Skill.Combine(rhs.Skill);
                ret.Unknown4 = this.Unknown4.Combine(rhs.Unknown4);
                ret.Resist = this.Resist.Combine(rhs.Resist);
                ret.Unknown5 = this.Unknown5.Combine(rhs.Unknown5);
                ret.Stagger = this.Stagger.Combine(rhs.Stagger);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool AnimationType;
            public bool Unused;
            public bool Speed;
            public bool Reach;
            public bool Flags;
            public bool Unused2;
            public bool SightFOV;
            public bool Unknown;
            public bool BaseVATStoHitChance;
            public bool AttackAnimation;
            public bool NumProjectiles;
            public bool EmbeddedWeaponAV;
            public bool RangeMin;
            public bool RangeMax;
            public bool OnHit;
            public bool AnimationAttackMult;
            public bool Unknown2;
            public bool RumbleLeftMotorStrength;
            public bool RumbleRightMotorStrength;
            public bool RumbleDuration;
            public bool Unknown3;
            public bool Skill;
            public bool Unknown4;
            public bool Resist;
            public bool Unknown5;
            public bool Stagger;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.AnimationType = defaultOn;
                this.Unused = defaultOn;
                this.Speed = defaultOn;
                this.Reach = defaultOn;
                this.Flags = defaultOn;
                this.Unused2 = defaultOn;
                this.SightFOV = defaultOn;
                this.Unknown = defaultOn;
                this.BaseVATStoHitChance = defaultOn;
                this.AttackAnimation = defaultOn;
                this.NumProjectiles = defaultOn;
                this.EmbeddedWeaponAV = defaultOn;
                this.RangeMin = defaultOn;
                this.RangeMax = defaultOn;
                this.OnHit = defaultOn;
                this.AnimationAttackMult = defaultOn;
                this.Unknown2 = defaultOn;
                this.RumbleLeftMotorStrength = defaultOn;
                this.RumbleRightMotorStrength = defaultOn;
                this.RumbleDuration = defaultOn;
                this.Unknown3 = defaultOn;
                this.Skill = defaultOn;
                this.Unknown4 = defaultOn;
                this.Resist = defaultOn;
                this.Unknown5 = defaultOn;
                this.Stagger = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((AnimationType, null));
                ret.Add((Unused, null));
                ret.Add((Speed, null));
                ret.Add((Reach, null));
                ret.Add((Flags, null));
                ret.Add((Unused2, null));
                ret.Add((SightFOV, null));
                ret.Add((Unknown, null));
                ret.Add((BaseVATStoHitChance, null));
                ret.Add((AttackAnimation, null));
                ret.Add((NumProjectiles, null));
                ret.Add((EmbeddedWeaponAV, null));
                ret.Add((RangeMin, null));
                ret.Add((RangeMax, null));
                ret.Add((OnHit, null));
                ret.Add((AnimationAttackMult, null));
                ret.Add((Unknown2, null));
                ret.Add((RumbleLeftMotorStrength, null));
                ret.Add((RumbleRightMotorStrength, null));
                ret.Add((RumbleDuration, null));
                ret.Add((Unknown3, null));
                ret.Add((Skill, null));
                ret.Add((Unknown4, null));
                ret.Add((Resist, null));
                ret.Add((Unknown5, null));
                ret.Add((Stagger, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = WeaponData_Registration.TriggeringRecordType;
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => WeaponDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        public static WeaponData CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new WeaponData();
            ((WeaponDataSetterCommon)((IWeaponDataGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out WeaponData item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(frame, recordTypeConverter);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        void IClearable.Clear()
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static WeaponData GetNew()
        {
            return new WeaponData();
        }

    }
    #endregion

    #region Interface
    public partial interface IWeaponData :
        IWeaponDataGetter,
        ILoquiObjectSetter<IWeaponData>
    {
        new WeaponAnimationType AnimationType { get; set; }
        new MemorySlice<Byte> Unused { get; set; }
        new Single Speed { get; set; }
        new Single Reach { get; set; }
        new WeaponData.Flag Flags { get; set; }
        new Int16 Unused2 { get; set; }
        new Single SightFOV { get; set; }
        new Int32 Unknown { get; set; }
        new Byte BaseVATStoHitChance { get; set; }
        new WeaponData.AttackAnimationType AttackAnimation { get; set; }
        new Byte NumProjectiles { get; set; }
        new Byte EmbeddedWeaponAV { get; set; }
        new Single RangeMin { get; set; }
        new Single RangeMax { get; set; }
        new WeaponData.OnHitType OnHit { get; set; }
        new Single AnimationAttackMult { get; set; }
        new Int32 Unknown2 { get; set; }
        new Single RumbleLeftMotorStrength { get; set; }
        new Single RumbleRightMotorStrength { get; set; }
        new Single RumbleDuration { get; set; }
        new MemorySlice<Byte> Unknown3 { get; set; }
        new Skill? Skill { get; set; }
        new Int64 Unknown4 { get; set; }
        new ActorValue Resist { get; set; }
        new Int32 Unknown5 { get; set; }
        new Single Stagger { get; set; }
    }

    public partial interface IWeaponDataGetter :
        ILoquiObject,
        ILoquiObject<IWeaponDataGetter>,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration Registration => WeaponData_Registration.Instance;
        WeaponAnimationType AnimationType { get; }
        ReadOnlyMemorySlice<Byte> Unused { get; }
        Single Speed { get; }
        Single Reach { get; }
        WeaponData.Flag Flags { get; }
        Int16 Unused2 { get; }
        Single SightFOV { get; }
        Int32 Unknown { get; }
        Byte BaseVATStoHitChance { get; }
        WeaponData.AttackAnimationType AttackAnimation { get; }
        Byte NumProjectiles { get; }
        Byte EmbeddedWeaponAV { get; }
        Single RangeMin { get; }
        Single RangeMax { get; }
        WeaponData.OnHitType OnHit { get; }
        Single AnimationAttackMult { get; }
        Int32 Unknown2 { get; }
        Single RumbleLeftMotorStrength { get; }
        Single RumbleRightMotorStrength { get; }
        Single RumbleDuration { get; }
        ReadOnlyMemorySlice<Byte> Unknown3 { get; }
        Skill? Skill { get; }
        Int64 Unknown4 { get; }
        ActorValue Resist { get; }
        Int32 Unknown5 { get; }
        Single Stagger { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class WeaponDataMixIn
    {
        public static void Clear(this IWeaponData item)
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static WeaponData.Mask<bool> GetEqualsMask(
            this IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IWeaponDataGetter item,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IWeaponDataGetter item,
            FileGeneration fg,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IWeaponDataGetter item,
            IWeaponDataGetter rhs)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            WeaponData.TranslationMask? copyMask = null)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IWeaponData lhs,
            IWeaponDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            WeaponData.TranslationMask? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static WeaponData DeepCopy(
            this IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IWeaponData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataSetterCommon)((IWeaponDataGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4.Internals
{
    #region Field Index
    public enum WeaponData_FieldIndex
    {
        AnimationType = 0,
        Unused = 1,
        Speed = 2,
        Reach = 3,
        Flags = 4,
        Unused2 = 5,
        SightFOV = 6,
        Unknown = 7,
        BaseVATStoHitChance = 8,
        AttackAnimation = 9,
        NumProjectiles = 10,
        EmbeddedWeaponAV = 11,
        RangeMin = 12,
        RangeMax = 13,
        OnHit = 14,
        AnimationAttackMult = 15,
        Unknown2 = 16,
        RumbleLeftMotorStrength = 17,
        RumbleRightMotorStrength = 18,
        RumbleDuration = 19,
        Unknown3 = 20,
        Skill = 21,
        Unknown4 = 22,
        Resist = 23,
        Unknown5 = 24,
        Stagger = 25,
    }
    #endregion

    #region Registration
    public partial class WeaponData_Registration : ILoquiRegistration
    {
        public static readonly WeaponData_Registration Instance = new WeaponData_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 197,
            version: 0);

        public const string GUID = "e4fd60a3-168d-4947-be5a-75a762ff8b1f";

        public const ushort AdditionalFieldCount = 26;

        public const ushort FieldCount = 26;

        public static readonly Type MaskType = typeof(WeaponData.Mask<>);

        public static readonly Type ErrorMaskType = typeof(WeaponData.ErrorMask);

        public static readonly Type ClassType = typeof(WeaponData);

        public static readonly Type GetterType = typeof(IWeaponDataGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IWeaponData);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout4.WeaponData";

        public const string Name = "WeaponData";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.DNAM;
        public static readonly Type BinaryWriteTranslation = typeof(WeaponDataBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    public partial class WeaponDataSetterCommon
    {
        public static readonly WeaponDataSetterCommon Instance = new WeaponDataSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IWeaponData item)
        {
            ClearPartial();
            item.AnimationType = default;
            item.Unused = new byte[3];
            item.Speed = default;
            item.Reach = default;
            item.Flags = default;
            item.Unused2 = default;
            item.SightFOV = default;
            item.Unknown = default;
            item.BaseVATStoHitChance = default;
            item.AttackAnimation = WeaponData._AttackAnimation_Default;
            item.NumProjectiles = default;
            item.EmbeddedWeaponAV = default;
            item.RangeMin = default;
            item.RangeMax = default;
            item.OnHit = default;
            item.AnimationAttackMult = default;
            item.Unknown2 = default;
            item.RumbleLeftMotorStrength = default;
            item.RumbleRightMotorStrength = default;
            item.RumbleDuration = default;
            item.Unknown3 = new byte[12];
            item.Skill = default;
            item.Unknown4 = default;
            item.Resist = WeaponData._Resist_Default;
            item.Unknown5 = default;
            item.Stagger = default;
        }
        
        #region Mutagen
        public void RemapLinks(IWeaponData obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IWeaponData item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseSubrecord(
                frame.Reader,
                recordTypeConverter.ConvertToCustom(RecordTypes.DNAM)));
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: WeaponDataBinaryCreateTranslation.FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class WeaponDataCommon
    {
        public static readonly WeaponDataCommon Instance = new WeaponDataCommon();

        public WeaponData.Mask<bool> GetEqualsMask(
            IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new WeaponData.Mask<bool>(false);
            ((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IWeaponDataGetter item,
            IWeaponDataGetter rhs,
            WeaponData.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.AnimationType = item.AnimationType == rhs.AnimationType;
            ret.Unused = MemoryExtensions.SequenceEqual(item.Unused.Span, rhs.Unused.Span);
            ret.Speed = item.Speed.EqualsWithin(rhs.Speed);
            ret.Reach = item.Reach.EqualsWithin(rhs.Reach);
            ret.Flags = item.Flags == rhs.Flags;
            ret.Unused2 = item.Unused2 == rhs.Unused2;
            ret.SightFOV = item.SightFOV.EqualsWithin(rhs.SightFOV);
            ret.Unknown = item.Unknown == rhs.Unknown;
            ret.BaseVATStoHitChance = item.BaseVATStoHitChance == rhs.BaseVATStoHitChance;
            ret.AttackAnimation = item.AttackAnimation == rhs.AttackAnimation;
            ret.NumProjectiles = item.NumProjectiles == rhs.NumProjectiles;
            ret.EmbeddedWeaponAV = item.EmbeddedWeaponAV == rhs.EmbeddedWeaponAV;
            ret.RangeMin = item.RangeMin.EqualsWithin(rhs.RangeMin);
            ret.RangeMax = item.RangeMax.EqualsWithin(rhs.RangeMax);
            ret.OnHit = item.OnHit == rhs.OnHit;
            ret.AnimationAttackMult = item.AnimationAttackMult.EqualsWithin(rhs.AnimationAttackMult);
            ret.Unknown2 = item.Unknown2 == rhs.Unknown2;
            ret.RumbleLeftMotorStrength = item.RumbleLeftMotorStrength.EqualsWithin(rhs.RumbleLeftMotorStrength);
            ret.RumbleRightMotorStrength = item.RumbleRightMotorStrength.EqualsWithin(rhs.RumbleRightMotorStrength);
            ret.RumbleDuration = item.RumbleDuration.EqualsWithin(rhs.RumbleDuration);
            ret.Unknown3 = MemoryExtensions.SequenceEqual(item.Unknown3.Span, rhs.Unknown3.Span);
            ret.Skill = item.Skill == rhs.Skill;
            ret.Unknown4 = item.Unknown4 == rhs.Unknown4;
            ret.Resist = item.Resist == rhs.Resist;
            ret.Unknown5 = item.Unknown5 == rhs.Unknown5;
            ret.Stagger = item.Stagger.EqualsWithin(rhs.Stagger);
        }
        
        public string ToString(
            IWeaponDataGetter item,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IWeaponDataGetter item,
            FileGeneration fg,
            string? name = null,
            WeaponData.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"WeaponData =>");
            }
            else
            {
                fg.AppendLine($"{name} (WeaponData) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IWeaponDataGetter item,
            FileGeneration fg,
            WeaponData.Mask<bool>? printMask = null)
        {
            if (printMask?.AnimationType ?? true)
            {
                fg.AppendItem(item.AnimationType, "AnimationType");
            }
            if (printMask?.Unused ?? true)
            {
                fg.AppendLine($"Unused => {SpanExt.ToHexString(item.Unused)}");
            }
            if (printMask?.Speed ?? true)
            {
                fg.AppendItem(item.Speed, "Speed");
            }
            if (printMask?.Reach ?? true)
            {
                fg.AppendItem(item.Reach, "Reach");
            }
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.Unused2 ?? true)
            {
                fg.AppendItem(item.Unused2, "Unused2");
            }
            if (printMask?.SightFOV ?? true)
            {
                fg.AppendItem(item.SightFOV, "SightFOV");
            }
            if (printMask?.Unknown ?? true)
            {
                fg.AppendItem(item.Unknown, "Unknown");
            }
            if (printMask?.BaseVATStoHitChance ?? true)
            {
                fg.AppendItem(item.BaseVATStoHitChance, "BaseVATStoHitChance");
            }
            if (printMask?.AttackAnimation ?? true)
            {
                fg.AppendItem(item.AttackAnimation, "AttackAnimation");
            }
            if (printMask?.NumProjectiles ?? true)
            {
                fg.AppendItem(item.NumProjectiles, "NumProjectiles");
            }
            if (printMask?.EmbeddedWeaponAV ?? true)
            {
                fg.AppendItem(item.EmbeddedWeaponAV, "EmbeddedWeaponAV");
            }
            if (printMask?.RangeMin ?? true)
            {
                fg.AppendItem(item.RangeMin, "RangeMin");
            }
            if (printMask?.RangeMax ?? true)
            {
                fg.AppendItem(item.RangeMax, "RangeMax");
            }
            if (printMask?.OnHit ?? true)
            {
                fg.AppendItem(item.OnHit, "OnHit");
            }
            if (printMask?.AnimationAttackMult ?? true)
            {
                fg.AppendItem(item.AnimationAttackMult, "AnimationAttackMult");
            }
            if (printMask?.Unknown2 ?? true)
            {
                fg.AppendItem(item.Unknown2, "Unknown2");
            }
            if (printMask?.RumbleLeftMotorStrength ?? true)
            {
                fg.AppendItem(item.RumbleLeftMotorStrength, "RumbleLeftMotorStrength");
            }
            if (printMask?.RumbleRightMotorStrength ?? true)
            {
                fg.AppendItem(item.RumbleRightMotorStrength, "RumbleRightMotorStrength");
            }
            if (printMask?.RumbleDuration ?? true)
            {
                fg.AppendItem(item.RumbleDuration, "RumbleDuration");
            }
            if (printMask?.Unknown3 ?? true)
            {
                fg.AppendLine($"Unknown3 => {SpanExt.ToHexString(item.Unknown3)}");
            }
            if ((printMask?.Skill ?? true)
                && item.Skill.TryGet(out var SkillItem))
            {
                fg.AppendItem(SkillItem, "Skill");
            }
            if (printMask?.Unknown4 ?? true)
            {
                fg.AppendItem(item.Unknown4, "Unknown4");
            }
            if (printMask?.Resist ?? true)
            {
                fg.AppendItem(item.Resist, "Resist");
            }
            if (printMask?.Unknown5 ?? true)
            {
                fg.AppendItem(item.Unknown5, "Unknown5");
            }
            if (printMask?.Stagger ?? true)
            {
                fg.AppendItem(item.Stagger, "Stagger");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IWeaponDataGetter? lhs,
            IWeaponDataGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (lhs.AnimationType != rhs.AnimationType) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unused.Span, rhs.Unused.Span)) return false;
            if (!lhs.Speed.EqualsWithin(rhs.Speed)) return false;
            if (!lhs.Reach.EqualsWithin(rhs.Reach)) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.Unused2 != rhs.Unused2) return false;
            if (!lhs.SightFOV.EqualsWithin(rhs.SightFOV)) return false;
            if (lhs.Unknown != rhs.Unknown) return false;
            if (lhs.BaseVATStoHitChance != rhs.BaseVATStoHitChance) return false;
            if (lhs.AttackAnimation != rhs.AttackAnimation) return false;
            if (lhs.NumProjectiles != rhs.NumProjectiles) return false;
            if (lhs.EmbeddedWeaponAV != rhs.EmbeddedWeaponAV) return false;
            if (!lhs.RangeMin.EqualsWithin(rhs.RangeMin)) return false;
            if (!lhs.RangeMax.EqualsWithin(rhs.RangeMax)) return false;
            if (lhs.OnHit != rhs.OnHit) return false;
            if (!lhs.AnimationAttackMult.EqualsWithin(rhs.AnimationAttackMult)) return false;
            if (lhs.Unknown2 != rhs.Unknown2) return false;
            if (!lhs.RumbleLeftMotorStrength.EqualsWithin(rhs.RumbleLeftMotorStrength)) return false;
            if (!lhs.RumbleRightMotorStrength.EqualsWithin(rhs.RumbleRightMotorStrength)) return false;
            if (!lhs.RumbleDuration.EqualsWithin(rhs.RumbleDuration)) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unknown3.Span, rhs.Unknown3.Span)) return false;
            if (lhs.Skill != rhs.Skill) return false;
            if (lhs.Unknown4 != rhs.Unknown4) return false;
            if (lhs.Resist != rhs.Resist) return false;
            if (lhs.Unknown5 != rhs.Unknown5) return false;
            if (!lhs.Stagger.EqualsWithin(rhs.Stagger)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IWeaponDataGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.AnimationType);
            hash.Add(item.Unused);
            hash.Add(item.Speed);
            hash.Add(item.Reach);
            hash.Add(item.Flags);
            hash.Add(item.Unused2);
            hash.Add(item.SightFOV);
            hash.Add(item.Unknown);
            hash.Add(item.BaseVATStoHitChance);
            hash.Add(item.AttackAnimation);
            hash.Add(item.NumProjectiles);
            hash.Add(item.EmbeddedWeaponAV);
            hash.Add(item.RangeMin);
            hash.Add(item.RangeMax);
            hash.Add(item.OnHit);
            hash.Add(item.AnimationAttackMult);
            hash.Add(item.Unknown2);
            hash.Add(item.RumbleLeftMotorStrength);
            hash.Add(item.RumbleRightMotorStrength);
            hash.Add(item.RumbleDuration);
            hash.Add(item.Unknown3);
            if (item.Skill.TryGet(out var Skillitem))
            {
                hash.Add(Skillitem);
            }
            hash.Add(item.Unknown4);
            hash.Add(item.Resist);
            hash.Add(item.Unknown5);
            hash.Add(item.Stagger);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return WeaponData.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<FormLinkInformation> GetContainedFormLinks(IWeaponDataGetter obj)
        {
            yield break;
        }
        
        #endregion
        
    }
    public partial class WeaponDataSetterTranslationCommon
    {
        public static readonly WeaponDataSetterTranslationCommon Instance = new WeaponDataSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IWeaponData item,
            IWeaponDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationType) ?? true))
            {
                item.AnimationType = rhs.AnimationType;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused) ?? true))
            {
                item.Unused = rhs.Unused.ToArray();
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Speed) ?? true))
            {
                item.Speed = rhs.Speed;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Reach) ?? true))
            {
                item.Reach = rhs.Reach;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unused2) ?? true))
            {
                item.Unused2 = rhs.Unused2;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.SightFOV) ?? true))
            {
                item.SightFOV = rhs.SightFOV;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown) ?? true))
            {
                item.Unknown = rhs.Unknown;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.BaseVATStoHitChance) ?? true))
            {
                item.BaseVATStoHitChance = rhs.BaseVATStoHitChance;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AttackAnimation) ?? true))
            {
                item.AttackAnimation = rhs.AttackAnimation;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.NumProjectiles) ?? true))
            {
                item.NumProjectiles = rhs.NumProjectiles;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.EmbeddedWeaponAV) ?? true))
            {
                item.EmbeddedWeaponAV = rhs.EmbeddedWeaponAV;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMin) ?? true))
            {
                item.RangeMin = rhs.RangeMin;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RangeMax) ?? true))
            {
                item.RangeMax = rhs.RangeMax;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.OnHit) ?? true))
            {
                item.OnHit = rhs.OnHit;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.AnimationAttackMult) ?? true))
            {
                item.AnimationAttackMult = rhs.AnimationAttackMult;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2 = rhs.Unknown2;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleLeftMotorStrength) ?? true))
            {
                item.RumbleLeftMotorStrength = rhs.RumbleLeftMotorStrength;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleRightMotorStrength) ?? true))
            {
                item.RumbleRightMotorStrength = rhs.RumbleRightMotorStrength;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.RumbleDuration) ?? true))
            {
                item.RumbleDuration = rhs.RumbleDuration;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown3) ?? true))
            {
                item.Unknown3 = rhs.Unknown3.ToArray();
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Skill) ?? true))
            {
                item.Skill = rhs.Skill;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown4) ?? true))
            {
                item.Unknown4 = rhs.Unknown4;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Resist) ?? true))
            {
                item.Resist = rhs.Resist;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Unknown5) ?? true))
            {
                item.Unknown5 = rhs.Unknown5;
            }
            if ((copyMask?.GetShouldTranslate((int)WeaponData_FieldIndex.Stagger) ?? true))
            {
                item.Stagger = rhs.Stagger;
            }
        }
        
        #endregion
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            WeaponData.TranslationMask? copyMask = null)
        {
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            out WeaponData.ErrorMask errorMask,
            WeaponData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = WeaponData.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public WeaponData DeepCopy(
            IWeaponDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            WeaponData ret = (WeaponData)((WeaponDataCommon)((IWeaponDataGetter)item).CommonInstance()!).GetNew();
            ((WeaponDataSetterTranslationCommon)((IWeaponDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class WeaponData
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => WeaponData_Registration.Instance;
        public static WeaponData_Registration Registration => WeaponData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => WeaponDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return WeaponDataSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => WeaponDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class WeaponDataBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static WeaponDataBinaryWriteTranslation Instance = new WeaponDataBinaryWriteTranslation();

        static partial void WriteBinaryFlagsCustom(
            MutagenWriter writer,
            IWeaponDataGetter item);

        public static void WriteBinaryFlags(
            MutagenWriter writer,
            IWeaponDataGetter item)
        {
            WriteBinaryFlagsCustom(
                writer: writer,
                item: item);
        }

        static partial void WriteBinaryFlags2Custom(
            MutagenWriter writer,
            IWeaponDataGetter item);

        public static void WriteBinaryFlags2(
            MutagenWriter writer,
            IWeaponDataGetter item)
        {
            WriteBinaryFlags2Custom(
                writer: writer,
                item: item);
        }

        public static void WriteEmbedded(
            IWeaponDataGetter item,
            MutagenWriter writer)
        {
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponAnimationType>.Instance.Write(
                writer,
                item.AnimationType,
                length: 1);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unused);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Speed);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Reach);
            WeaponDataBinaryWriteTranslation.WriteBinaryFlags(
                writer: writer,
                item: item);
            writer.Write(item.Unused2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SightFOV);
            writer.Write(item.Unknown);
            writer.Write(item.BaseVATStoHitChance);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponData.AttackAnimationType>.Instance.Write(
                writer,
                item.AttackAnimation,
                length: 1);
            writer.Write(item.NumProjectiles);
            writer.Write(item.EmbeddedWeaponAV);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RangeMin);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RangeMax);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<WeaponData.OnHitType>.Instance.Write(
                writer,
                item.OnHit,
                length: 4);
            WeaponDataBinaryWriteTranslation.WriteBinaryFlags2(
                writer: writer,
                item: item);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.AnimationAttackMult);
            writer.Write(item.Unknown2);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleLeftMotorStrength);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleRightMotorStrength);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.RumbleDuration);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown3);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<Skill>.Instance.Write(
                writer,
                ((int?)item.Skill) ?? -1,
                length: 4);
            writer.Write(item.Unknown4);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<ActorValue>.Instance.Write(
                writer,
                item.Resist,
                length: 4);
            writer.Write(item.Unknown5);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Stagger);
        }

        public void Write(
            MutagenWriter writer,
            IWeaponDataGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            using (HeaderExport.Header(
                writer: writer,
                record: recordTypeConverter.ConvertToCustom(RecordTypes.DNAM),
                type: Mutagen.Bethesda.Binary.ObjectType.Subrecord))
            {
                WriteEmbedded(
                    item: item,
                    writer: writer);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IWeaponDataGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class WeaponDataBinaryCreateTranslation
    {
        public readonly static WeaponDataBinaryCreateTranslation Instance = new WeaponDataBinaryCreateTranslation();

        public static void FillBinaryStructs(
            IWeaponData item,
            MutagenFrame frame)
        {
            item.AnimationType = EnumBinaryTranslation<WeaponAnimationType>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.Unused = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(3));
            item.Speed = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Reach = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            WeaponDataBinaryCreateTranslation.FillBinaryFlagsCustom(
                frame: frame,
                item: item);
            item.Unused2 = frame.ReadInt16();
            item.SightFOV = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown = frame.ReadInt32();
            item.BaseVATStoHitChance = frame.ReadUInt8();
            item.AttackAnimation = EnumBinaryTranslation<WeaponData.AttackAnimationType>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.NumProjectiles = frame.ReadUInt8();
            item.EmbeddedWeaponAV = frame.ReadUInt8();
            item.RangeMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RangeMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.OnHit = EnumBinaryTranslation<WeaponData.OnHitType>.Instance.Parse(frame: frame.SpawnWithLength(4));
            WeaponDataBinaryCreateTranslation.FillBinaryFlags2Custom(
                frame: frame,
                item: item);
            item.AnimationAttackMult = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown2 = frame.ReadInt32();
            item.RumbleLeftMotorStrength = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RumbleRightMotorStrength = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.RumbleDuration = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown3 = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(12));
            if (frame.Complete) return;
            item.Skill = EnumBinaryTranslation<Skill>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.Unknown4 = frame.ReadInt64();
            item.Resist = EnumBinaryTranslation<ActorValue>.Instance.Parse(frame: frame.SpawnWithLength(4));
            item.Unknown5 = frame.ReadInt32();
            item.Stagger = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
        }

        static partial void FillBinaryFlagsCustom(
            MutagenFrame frame,
            IWeaponData item);

        static partial void FillBinaryFlags2Custom(
            MutagenFrame frame,
            IWeaponData item);

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class WeaponDataBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IWeaponDataGetter item,
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class WeaponDataBinaryOverlay :
        BinaryOverlay,
        IWeaponDataGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => WeaponData_Registration.Instance;
        public static WeaponData_Registration Registration => WeaponData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => WeaponDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => WeaponDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IWeaponDataGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IWeaponDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => WeaponDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((WeaponDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public WeaponAnimationType AnimationType => (WeaponAnimationType)_data.Span.Slice(0x0, 0x1)[0];
        public ReadOnlyMemorySlice<Byte> Unused => _data.Span.Slice(0x1, 0x3).ToArray();
        public Single Speed => _data.Slice(0x4, 0x4).Float();
        public Single Reach => _data.Slice(0x8, 0x4).Float();
        public WeaponData.Flag Flags => GetFlagsCustom(location: 0xC);
        public Int16 Unused2 => BinaryPrimitives.ReadInt16LittleEndian(_data.Slice(0xE, 0x2));
        public Single SightFOV => _data.Slice(0x10, 0x4).Float();
        public Int32 Unknown => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x14, 0x4));
        public Byte BaseVATStoHitChance => _data.Span[0x18];
        public WeaponData.AttackAnimationType AttackAnimation => (WeaponData.AttackAnimationType)_data.Span.Slice(0x19, 0x1)[0];
        public Byte NumProjectiles => _data.Span[0x1A];
        public Byte EmbeddedWeaponAV => _data.Span[0x1B];
        public Single RangeMin => _data.Slice(0x1C, 0x4).Float();
        public Single RangeMax => _data.Slice(0x20, 0x4).Float();
        public WeaponData.OnHitType OnHit => (WeaponData.OnHitType)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x24, 0x4));
        #region Flags2
        partial void Flags2CustomParse(
            OverlayStream stream,
            int offset);
        #endregion
        public Single AnimationAttackMult => _data.Slice(0x2C, 0x4).Float();
        public Int32 Unknown2 => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x30, 0x4));
        public Single RumbleLeftMotorStrength => _data.Slice(0x34, 0x4).Float();
        public Single RumbleRightMotorStrength => _data.Slice(0x38, 0x4).Float();
        public Single RumbleDuration => _data.Slice(0x3C, 0x4).Float();
        public ReadOnlyMemorySlice<Byte> Unknown3 => _data.Span.Slice(0x40, 0xC).ToArray();
        #region Skill
        public Skill? Skill
        {
            get
            {
                var val = (Skill)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x4C, 0x4));
                if (((int)val) == -1) return null;
                return val;
            }
        }
        #endregion
        public Int64 Unknown4 => BinaryPrimitives.ReadInt64LittleEndian(_data.Slice(0x50, 0x8));
        public ActorValue Resist => (ActorValue)BinaryPrimitives.ReadInt32LittleEndian(_data.Span.Slice(0x58, 0x4));
        public Int32 Unknown5 => BinaryPrimitives.ReadInt32LittleEndian(_data.Slice(0x5C, 0x4));
        public Single Stagger => _data.Slice(0x60, 0x4).Float();
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected WeaponDataBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static WeaponDataBinaryOverlay WeaponDataFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new WeaponDataBinaryOverlay(
                bytes: HeaderTranslation.ExtractSubrecordMemory(stream.RemainingMemory, package.MetaData.Constants),
                package: package);
            var finalPos = checked((int)(stream.Position + stream.GetSubrecord().TotalLength));
            int offset = stream.Position + package.MetaData.Constants.SubConstants.TypeAndLengthLength;
            stream.Position += 0x64 + package.MetaData.Constants.SubConstants.HeaderLength;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static WeaponDataBinaryOverlay WeaponDataFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return WeaponDataFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            WeaponDataMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IWeaponDataGetter rhs)) return false;
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(IWeaponDataGetter? obj)
        {
            return ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((WeaponDataCommon)((IWeaponDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

