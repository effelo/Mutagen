/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Internals;
using Mutagen.Bethesda.Fallout4.Internals;
using Noggog;
using System;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Text;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class RegionObject :
        IRegionObject,
        ILoquiObjectSetter<RegionObject>,
        IEquatable<IRegionObjectGetter>
    {
        #region Ctor
        public RegionObject()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Object
        public FormLink<IRegionTargetGetter> Object { get; set; } = new FormLink<IRegionTargetGetter>();
        #endregion
        #region ParentIndex
        public UInt16 ParentIndex { get; set; } = default;
        #endregion
        #region Unknown
        public UInt16 Unknown { get; set; } = default;
        #endregion
        #region Density
        public Single Density { get; set; } = default;
        #endregion
        #region Clustering
        public Byte Clustering { get; set; } = default;
        #endregion
        #region MinSlope
        public Byte MinSlope { get; set; } = default;
        #endregion
        #region MaxSlope
        public Byte MaxSlope { get; set; } = default;
        #endregion
        #region Flags
        public RegionObject.Flag Flags { get; set; } = default;
        #endregion
        #region RadiusWrtPercent
        public UInt16 RadiusWrtPercent { get; set; } = default;
        #endregion
        #region Radius
        public UInt16 Radius { get; set; } = default;
        #endregion
        #region MinHeight
        public Single MinHeight { get; set; } = default;
        #endregion
        #region MaxHeight
        public Single MaxHeight { get; set; } = default;
        #endregion
        #region Sink
        public Single Sink { get; set; } = default;
        #endregion
        #region SinkVariance
        public Single SinkVariance { get; set; } = default;
        #endregion
        #region SizeVariance
        public Single SizeVariance { get; set; } = default;
        #endregion
        #region AngleVariance
        public P3UInt16 AngleVariance { get; set; } = default;
        #endregion
        #region Unknown2
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private MemorySlice<Byte> _Unknown2 = new byte[6];
        public MemorySlice<Byte> Unknown2
        {
            get => _Unknown2;
            set => this._Unknown2 = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte> IRegionObjectGetter.Unknown2 => this.Unknown2;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            RegionObjectMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IRegionObjectGetter rhs)) return false;
            return ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(IRegionObjectGetter? obj)
        {
            return ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Object = initialValue;
                this.ParentIndex = initialValue;
                this.Unknown = initialValue;
                this.Density = initialValue;
                this.Clustering = initialValue;
                this.MinSlope = initialValue;
                this.MaxSlope = initialValue;
                this.Flags = initialValue;
                this.RadiusWrtPercent = initialValue;
                this.Radius = initialValue;
                this.MinHeight = initialValue;
                this.MaxHeight = initialValue;
                this.Sink = initialValue;
                this.SinkVariance = initialValue;
                this.SizeVariance = initialValue;
                this.AngleVariance = initialValue;
                this.Unknown2 = initialValue;
            }

            public Mask(
                TItem Object,
                TItem ParentIndex,
                TItem Unknown,
                TItem Density,
                TItem Clustering,
                TItem MinSlope,
                TItem MaxSlope,
                TItem Flags,
                TItem RadiusWrtPercent,
                TItem Radius,
                TItem MinHeight,
                TItem MaxHeight,
                TItem Sink,
                TItem SinkVariance,
                TItem SizeVariance,
                TItem AngleVariance,
                TItem Unknown2)
            {
                this.Object = Object;
                this.ParentIndex = ParentIndex;
                this.Unknown = Unknown;
                this.Density = Density;
                this.Clustering = Clustering;
                this.MinSlope = MinSlope;
                this.MaxSlope = MaxSlope;
                this.Flags = Flags;
                this.RadiusWrtPercent = RadiusWrtPercent;
                this.Radius = Radius;
                this.MinHeight = MinHeight;
                this.MaxHeight = MaxHeight;
                this.Sink = Sink;
                this.SinkVariance = SinkVariance;
                this.SizeVariance = SizeVariance;
                this.AngleVariance = AngleVariance;
                this.Unknown2 = Unknown2;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Object;
            public TItem ParentIndex;
            public TItem Unknown;
            public TItem Density;
            public TItem Clustering;
            public TItem MinSlope;
            public TItem MaxSlope;
            public TItem Flags;
            public TItem RadiusWrtPercent;
            public TItem Radius;
            public TItem MinHeight;
            public TItem MaxHeight;
            public TItem Sink;
            public TItem SinkVariance;
            public TItem SizeVariance;
            public TItem AngleVariance;
            public TItem Unknown2;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Object, rhs.Object)) return false;
                if (!object.Equals(this.ParentIndex, rhs.ParentIndex)) return false;
                if (!object.Equals(this.Unknown, rhs.Unknown)) return false;
                if (!object.Equals(this.Density, rhs.Density)) return false;
                if (!object.Equals(this.Clustering, rhs.Clustering)) return false;
                if (!object.Equals(this.MinSlope, rhs.MinSlope)) return false;
                if (!object.Equals(this.MaxSlope, rhs.MaxSlope)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.RadiusWrtPercent, rhs.RadiusWrtPercent)) return false;
                if (!object.Equals(this.Radius, rhs.Radius)) return false;
                if (!object.Equals(this.MinHeight, rhs.MinHeight)) return false;
                if (!object.Equals(this.MaxHeight, rhs.MaxHeight)) return false;
                if (!object.Equals(this.Sink, rhs.Sink)) return false;
                if (!object.Equals(this.SinkVariance, rhs.SinkVariance)) return false;
                if (!object.Equals(this.SizeVariance, rhs.SizeVariance)) return false;
                if (!object.Equals(this.AngleVariance, rhs.AngleVariance)) return false;
                if (!object.Equals(this.Unknown2, rhs.Unknown2)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Object);
                hash.Add(this.ParentIndex);
                hash.Add(this.Unknown);
                hash.Add(this.Density);
                hash.Add(this.Clustering);
                hash.Add(this.MinSlope);
                hash.Add(this.MaxSlope);
                hash.Add(this.Flags);
                hash.Add(this.RadiusWrtPercent);
                hash.Add(this.Radius);
                hash.Add(this.MinHeight);
                hash.Add(this.MaxHeight);
                hash.Add(this.Sink);
                hash.Add(this.SinkVariance);
                hash.Add(this.SizeVariance);
                hash.Add(this.AngleVariance);
                hash.Add(this.Unknown2);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Object)) return false;
                if (!eval(this.ParentIndex)) return false;
                if (!eval(this.Unknown)) return false;
                if (!eval(this.Density)) return false;
                if (!eval(this.Clustering)) return false;
                if (!eval(this.MinSlope)) return false;
                if (!eval(this.MaxSlope)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.RadiusWrtPercent)) return false;
                if (!eval(this.Radius)) return false;
                if (!eval(this.MinHeight)) return false;
                if (!eval(this.MaxHeight)) return false;
                if (!eval(this.Sink)) return false;
                if (!eval(this.SinkVariance)) return false;
                if (!eval(this.SizeVariance)) return false;
                if (!eval(this.AngleVariance)) return false;
                if (!eval(this.Unknown2)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Object)) return true;
                if (eval(this.ParentIndex)) return true;
                if (eval(this.Unknown)) return true;
                if (eval(this.Density)) return true;
                if (eval(this.Clustering)) return true;
                if (eval(this.MinSlope)) return true;
                if (eval(this.MaxSlope)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.RadiusWrtPercent)) return true;
                if (eval(this.Radius)) return true;
                if (eval(this.MinHeight)) return true;
                if (eval(this.MaxHeight)) return true;
                if (eval(this.Sink)) return true;
                if (eval(this.SinkVariance)) return true;
                if (eval(this.SizeVariance)) return true;
                if (eval(this.AngleVariance)) return true;
                if (eval(this.Unknown2)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new RegionObject.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Object = eval(this.Object);
                obj.ParentIndex = eval(this.ParentIndex);
                obj.Unknown = eval(this.Unknown);
                obj.Density = eval(this.Density);
                obj.Clustering = eval(this.Clustering);
                obj.MinSlope = eval(this.MinSlope);
                obj.MaxSlope = eval(this.MaxSlope);
                obj.Flags = eval(this.Flags);
                obj.RadiusWrtPercent = eval(this.RadiusWrtPercent);
                obj.Radius = eval(this.Radius);
                obj.MinHeight = eval(this.MinHeight);
                obj.MaxHeight = eval(this.MaxHeight);
                obj.Sink = eval(this.Sink);
                obj.SinkVariance = eval(this.SinkVariance);
                obj.SizeVariance = eval(this.SizeVariance);
                obj.AngleVariance = eval(this.AngleVariance);
                obj.Unknown2 = eval(this.Unknown2);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(RegionObject.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, RegionObject.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(RegionObject.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.Object ?? true)
                    {
                        fg.AppendItem(Object, "Object");
                    }
                    if (printMask?.ParentIndex ?? true)
                    {
                        fg.AppendItem(ParentIndex, "ParentIndex");
                    }
                    if (printMask?.Unknown ?? true)
                    {
                        fg.AppendItem(Unknown, "Unknown");
                    }
                    if (printMask?.Density ?? true)
                    {
                        fg.AppendItem(Density, "Density");
                    }
                    if (printMask?.Clustering ?? true)
                    {
                        fg.AppendItem(Clustering, "Clustering");
                    }
                    if (printMask?.MinSlope ?? true)
                    {
                        fg.AppendItem(MinSlope, "MinSlope");
                    }
                    if (printMask?.MaxSlope ?? true)
                    {
                        fg.AppendItem(MaxSlope, "MaxSlope");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.RadiusWrtPercent ?? true)
                    {
                        fg.AppendItem(RadiusWrtPercent, "RadiusWrtPercent");
                    }
                    if (printMask?.Radius ?? true)
                    {
                        fg.AppendItem(Radius, "Radius");
                    }
                    if (printMask?.MinHeight ?? true)
                    {
                        fg.AppendItem(MinHeight, "MinHeight");
                    }
                    if (printMask?.MaxHeight ?? true)
                    {
                        fg.AppendItem(MaxHeight, "MaxHeight");
                    }
                    if (printMask?.Sink ?? true)
                    {
                        fg.AppendItem(Sink, "Sink");
                    }
                    if (printMask?.SinkVariance ?? true)
                    {
                        fg.AppendItem(SinkVariance, "SinkVariance");
                    }
                    if (printMask?.SizeVariance ?? true)
                    {
                        fg.AppendItem(SizeVariance, "SizeVariance");
                    }
                    if (printMask?.AngleVariance ?? true)
                    {
                        fg.AppendItem(AngleVariance, "AngleVariance");
                    }
                    if (printMask?.Unknown2 ?? true)
                    {
                        fg.AppendItem(Unknown2, "Unknown2");
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Object;
            public Exception? ParentIndex;
            public Exception? Unknown;
            public Exception? Density;
            public Exception? Clustering;
            public Exception? MinSlope;
            public Exception? MaxSlope;
            public Exception? Flags;
            public Exception? RadiusWrtPercent;
            public Exception? Radius;
            public Exception? MinHeight;
            public Exception? MaxHeight;
            public Exception? Sink;
            public Exception? SinkVariance;
            public Exception? SizeVariance;
            public Exception? AngleVariance;
            public Exception? Unknown2;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                RegionObject_FieldIndex enu = (RegionObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionObject_FieldIndex.Object:
                        return Object;
                    case RegionObject_FieldIndex.ParentIndex:
                        return ParentIndex;
                    case RegionObject_FieldIndex.Unknown:
                        return Unknown;
                    case RegionObject_FieldIndex.Density:
                        return Density;
                    case RegionObject_FieldIndex.Clustering:
                        return Clustering;
                    case RegionObject_FieldIndex.MinSlope:
                        return MinSlope;
                    case RegionObject_FieldIndex.MaxSlope:
                        return MaxSlope;
                    case RegionObject_FieldIndex.Flags:
                        return Flags;
                    case RegionObject_FieldIndex.RadiusWrtPercent:
                        return RadiusWrtPercent;
                    case RegionObject_FieldIndex.Radius:
                        return Radius;
                    case RegionObject_FieldIndex.MinHeight:
                        return MinHeight;
                    case RegionObject_FieldIndex.MaxHeight:
                        return MaxHeight;
                    case RegionObject_FieldIndex.Sink:
                        return Sink;
                    case RegionObject_FieldIndex.SinkVariance:
                        return SinkVariance;
                    case RegionObject_FieldIndex.SizeVariance:
                        return SizeVariance;
                    case RegionObject_FieldIndex.AngleVariance:
                        return AngleVariance;
                    case RegionObject_FieldIndex.Unknown2:
                        return Unknown2;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                RegionObject_FieldIndex enu = (RegionObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionObject_FieldIndex.Object:
                        this.Object = ex;
                        break;
                    case RegionObject_FieldIndex.ParentIndex:
                        this.ParentIndex = ex;
                        break;
                    case RegionObject_FieldIndex.Unknown:
                        this.Unknown = ex;
                        break;
                    case RegionObject_FieldIndex.Density:
                        this.Density = ex;
                        break;
                    case RegionObject_FieldIndex.Clustering:
                        this.Clustering = ex;
                        break;
                    case RegionObject_FieldIndex.MinSlope:
                        this.MinSlope = ex;
                        break;
                    case RegionObject_FieldIndex.MaxSlope:
                        this.MaxSlope = ex;
                        break;
                    case RegionObject_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case RegionObject_FieldIndex.RadiusWrtPercent:
                        this.RadiusWrtPercent = ex;
                        break;
                    case RegionObject_FieldIndex.Radius:
                        this.Radius = ex;
                        break;
                    case RegionObject_FieldIndex.MinHeight:
                        this.MinHeight = ex;
                        break;
                    case RegionObject_FieldIndex.MaxHeight:
                        this.MaxHeight = ex;
                        break;
                    case RegionObject_FieldIndex.Sink:
                        this.Sink = ex;
                        break;
                    case RegionObject_FieldIndex.SinkVariance:
                        this.SinkVariance = ex;
                        break;
                    case RegionObject_FieldIndex.SizeVariance:
                        this.SizeVariance = ex;
                        break;
                    case RegionObject_FieldIndex.AngleVariance:
                        this.AngleVariance = ex;
                        break;
                    case RegionObject_FieldIndex.Unknown2:
                        this.Unknown2 = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                RegionObject_FieldIndex enu = (RegionObject_FieldIndex)index;
                switch (enu)
                {
                    case RegionObject_FieldIndex.Object:
                        this.Object = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.ParentIndex:
                        this.ParentIndex = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Unknown:
                        this.Unknown = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Density:
                        this.Density = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Clustering:
                        this.Clustering = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.MinSlope:
                        this.MinSlope = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.MaxSlope:
                        this.MaxSlope = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.RadiusWrtPercent:
                        this.RadiusWrtPercent = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Radius:
                        this.Radius = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.MinHeight:
                        this.MinHeight = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.MaxHeight:
                        this.MaxHeight = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Sink:
                        this.Sink = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.SinkVariance:
                        this.SinkVariance = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.SizeVariance:
                        this.SizeVariance = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.AngleVariance:
                        this.AngleVariance = (Exception?)obj;
                        break;
                    case RegionObject_FieldIndex.Unknown2:
                        this.Unknown2 = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Object != null) return true;
                if (ParentIndex != null) return true;
                if (Unknown != null) return true;
                if (Density != null) return true;
                if (Clustering != null) return true;
                if (MinSlope != null) return true;
                if (MaxSlope != null) return true;
                if (Flags != null) return true;
                if (RadiusWrtPercent != null) return true;
                if (Radius != null) return true;
                if (MinHeight != null) return true;
                if (MaxHeight != null) return true;
                if (Sink != null) return true;
                if (SinkVariance != null) return true;
                if (SizeVariance != null) return true;
                if (AngleVariance != null) return true;
                if (Unknown2 != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(Object, "Object");
                fg.AppendItem(ParentIndex, "ParentIndex");
                fg.AppendItem(Unknown, "Unknown");
                fg.AppendItem(Density, "Density");
                fg.AppendItem(Clustering, "Clustering");
                fg.AppendItem(MinSlope, "MinSlope");
                fg.AppendItem(MaxSlope, "MaxSlope");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(RadiusWrtPercent, "RadiusWrtPercent");
                fg.AppendItem(Radius, "Radius");
                fg.AppendItem(MinHeight, "MinHeight");
                fg.AppendItem(MaxHeight, "MaxHeight");
                fg.AppendItem(Sink, "Sink");
                fg.AppendItem(SinkVariance, "SinkVariance");
                fg.AppendItem(SizeVariance, "SizeVariance");
                fg.AppendItem(AngleVariance, "AngleVariance");
                fg.AppendItem(Unknown2, "Unknown2");
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Object = this.Object.Combine(rhs.Object);
                ret.ParentIndex = this.ParentIndex.Combine(rhs.ParentIndex);
                ret.Unknown = this.Unknown.Combine(rhs.Unknown);
                ret.Density = this.Density.Combine(rhs.Density);
                ret.Clustering = this.Clustering.Combine(rhs.Clustering);
                ret.MinSlope = this.MinSlope.Combine(rhs.MinSlope);
                ret.MaxSlope = this.MaxSlope.Combine(rhs.MaxSlope);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.RadiusWrtPercent = this.RadiusWrtPercent.Combine(rhs.RadiusWrtPercent);
                ret.Radius = this.Radius.Combine(rhs.Radius);
                ret.MinHeight = this.MinHeight.Combine(rhs.MinHeight);
                ret.MaxHeight = this.MaxHeight.Combine(rhs.MaxHeight);
                ret.Sink = this.Sink.Combine(rhs.Sink);
                ret.SinkVariance = this.SinkVariance.Combine(rhs.SinkVariance);
                ret.SizeVariance = this.SizeVariance.Combine(rhs.SizeVariance);
                ret.AngleVariance = this.AngleVariance.Combine(rhs.AngleVariance);
                ret.Unknown2 = this.Unknown2.Combine(rhs.Unknown2);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool Object;
            public bool ParentIndex;
            public bool Unknown;
            public bool Density;
            public bool Clustering;
            public bool MinSlope;
            public bool MaxSlope;
            public bool Flags;
            public bool RadiusWrtPercent;
            public bool Radius;
            public bool MinHeight;
            public bool MaxHeight;
            public bool Sink;
            public bool SinkVariance;
            public bool SizeVariance;
            public bool AngleVariance;
            public bool Unknown2;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.Object = defaultOn;
                this.ParentIndex = defaultOn;
                this.Unknown = defaultOn;
                this.Density = defaultOn;
                this.Clustering = defaultOn;
                this.MinSlope = defaultOn;
                this.MaxSlope = defaultOn;
                this.Flags = defaultOn;
                this.RadiusWrtPercent = defaultOn;
                this.Radius = defaultOn;
                this.MinHeight = defaultOn;
                this.MaxHeight = defaultOn;
                this.Sink = defaultOn;
                this.SinkVariance = defaultOn;
                this.SizeVariance = defaultOn;
                this.AngleVariance = defaultOn;
                this.Unknown2 = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Object, null));
                ret.Add((ParentIndex, null));
                ret.Add((Unknown, null));
                ret.Add((Density, null));
                ret.Add((Clustering, null));
                ret.Add((MinSlope, null));
                ret.Add((MaxSlope, null));
                ret.Add((Flags, null));
                ret.Add((RadiusWrtPercent, null));
                ret.Add((Radius, null));
                ret.Add((MinHeight, null));
                ret.Add((MaxHeight, null));
                ret.Add((Sink, null));
                ret.Add((SinkVariance, null));
                ret.Add((SizeVariance, null));
                ret.Add((AngleVariance, null));
                ret.Add((Unknown2, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<FormLinkInformation> ContainedFormLinks => RegionObjectCommon.Instance.GetContainedFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => RegionObjectSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => RegionObjectBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionObjectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        public static RegionObject CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new RegionObject();
            ((RegionObjectSetterCommon)((IRegionObjectGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out RegionObject item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(frame, recordTypeConverter);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        void IClearable.Clear()
        {
            ((RegionObjectSetterCommon)((IRegionObjectGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static RegionObject GetNew()
        {
            return new RegionObject();
        }

    }
    #endregion

    #region Interface
    public partial interface IRegionObject :
        IRegionObjectGetter,
        ILoquiObjectSetter<IRegionObject>,
        IFormLinkContainer
    {
        new FormLink<IRegionTargetGetter> Object { get; set; }
        new UInt16 ParentIndex { get; set; }
        new UInt16 Unknown { get; set; }
        new Single Density { get; set; }
        new Byte Clustering { get; set; }
        new Byte MinSlope { get; set; }
        new Byte MaxSlope { get; set; }
        new RegionObject.Flag Flags { get; set; }
        new UInt16 RadiusWrtPercent { get; set; }
        new UInt16 Radius { get; set; }
        new Single MinHeight { get; set; }
        new Single MaxHeight { get; set; }
        new Single Sink { get; set; }
        new Single SinkVariance { get; set; }
        new Single SizeVariance { get; set; }
        new P3UInt16 AngleVariance { get; set; }
        new MemorySlice<Byte> Unknown2 { get; set; }
    }

    public partial interface IRegionObjectGetter :
        ILoquiObject,
        ILoquiObject<IRegionObjectGetter>,
        IFormLinkContainerGetter,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration Registration => RegionObject_Registration.Instance;
        FormLink<IRegionTargetGetter> Object { get; }
        UInt16 ParentIndex { get; }
        UInt16 Unknown { get; }
        Single Density { get; }
        Byte Clustering { get; }
        Byte MinSlope { get; }
        Byte MaxSlope { get; }
        RegionObject.Flag Flags { get; }
        UInt16 RadiusWrtPercent { get; }
        UInt16 Radius { get; }
        Single MinHeight { get; }
        Single MaxHeight { get; }
        Single Sink { get; }
        Single SinkVariance { get; }
        Single SizeVariance { get; }
        P3UInt16 AngleVariance { get; }
        ReadOnlyMemorySlice<Byte> Unknown2 { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class RegionObjectMixIn
    {
        public static void Clear(this IRegionObject item)
        {
            ((RegionObjectSetterCommon)((IRegionObjectGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static RegionObject.Mask<bool> GetEqualsMask(
            this IRegionObjectGetter item,
            IRegionObjectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IRegionObjectGetter item,
            string? name = null,
            RegionObject.Mask<bool>? printMask = null)
        {
            return ((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IRegionObjectGetter item,
            FileGeneration fg,
            string? name = null,
            RegionObject.Mask<bool>? printMask = null)
        {
            ((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IRegionObjectGetter item,
            IRegionObjectGetter rhs)
        {
            return ((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this IRegionObject lhs,
            IRegionObjectGetter rhs)
        {
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IRegionObject lhs,
            IRegionObjectGetter rhs,
            RegionObject.TranslationMask? copyMask = null)
        {
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IRegionObject lhs,
            IRegionObjectGetter rhs,
            out RegionObject.ErrorMask errorMask,
            RegionObject.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = RegionObject.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IRegionObject lhs,
            IRegionObjectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static RegionObject DeepCopy(
            this IRegionObjectGetter item,
            RegionObject.TranslationMask? copyMask = null)
        {
            return ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static RegionObject DeepCopy(
            this IRegionObjectGetter item,
            out RegionObject.ErrorMask errorMask,
            RegionObject.TranslationMask? copyMask = null)
        {
            return ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static RegionObject DeepCopy(
            this IRegionObjectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IRegionObject item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionObjectSetterCommon)((IRegionObjectGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4.Internals
{
    #region Field Index
    public enum RegionObject_FieldIndex
    {
        Object = 0,
        ParentIndex = 1,
        Unknown = 2,
        Density = 3,
        Clustering = 4,
        MinSlope = 5,
        MaxSlope = 6,
        Flags = 7,
        RadiusWrtPercent = 8,
        Radius = 9,
        MinHeight = 10,
        MaxHeight = 11,
        Sink = 12,
        SinkVariance = 13,
        SizeVariance = 14,
        AngleVariance = 15,
        Unknown2 = 16,
    }
    #endregion

    #region Registration
    public partial class RegionObject_Registration : ILoquiRegistration
    {
        public static readonly RegionObject_Registration Instance = new RegionObject_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 266,
            version: 0);

        public const string GUID = "97e90183-2a56-46b0-bbdd-014ba9cc25da";

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(RegionObject.Mask<>);

        public static readonly Type ErrorMaskType = typeof(RegionObject.ErrorMask);

        public static readonly Type ClassType = typeof(RegionObject);

        public static readonly Type GetterType = typeof(IRegionObjectGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IRegionObject);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout4.RegionObject";

        public const string Name = "RegionObject";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly Type BinaryWriteTranslation = typeof(RegionObjectBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    public partial class RegionObjectSetterCommon
    {
        public static readonly RegionObjectSetterCommon Instance = new RegionObjectSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IRegionObject item)
        {
            ClearPartial();
            item.Object = FormLink<IRegionTargetGetter>.Null;
            item.ParentIndex = default;
            item.Unknown = default;
            item.Density = default;
            item.Clustering = default;
            item.MinSlope = default;
            item.MaxSlope = default;
            item.Flags = default;
            item.RadiusWrtPercent = default;
            item.Radius = default;
            item.MinHeight = default;
            item.MaxHeight = default;
            item.Sink = default;
            item.SinkVariance = default;
            item.SizeVariance = default;
            item.AngleVariance = default;
            item.Unknown2 = new byte[6];
        }
        
        #region Mutagen
        public void RemapLinks(IRegionObject obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.Object = obj.Object.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IRegionObject item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: RegionObjectBinaryCreateTranslation.FillBinaryStructs);
        }
        
        #endregion
        
    }
    public partial class RegionObjectCommon
    {
        public static readonly RegionObjectCommon Instance = new RegionObjectCommon();

        public RegionObject.Mask<bool> GetEqualsMask(
            IRegionObjectGetter item,
            IRegionObjectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new RegionObject.Mask<bool>(false);
            ((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IRegionObjectGetter item,
            IRegionObjectGetter rhs,
            RegionObject.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Object = item.Object.Equals(rhs.Object);
            ret.ParentIndex = item.ParentIndex == rhs.ParentIndex;
            ret.Unknown = item.Unknown == rhs.Unknown;
            ret.Density = item.Density.EqualsWithin(rhs.Density);
            ret.Clustering = item.Clustering == rhs.Clustering;
            ret.MinSlope = item.MinSlope == rhs.MinSlope;
            ret.MaxSlope = item.MaxSlope == rhs.MaxSlope;
            ret.Flags = item.Flags == rhs.Flags;
            ret.RadiusWrtPercent = item.RadiusWrtPercent == rhs.RadiusWrtPercent;
            ret.Radius = item.Radius == rhs.Radius;
            ret.MinHeight = item.MinHeight.EqualsWithin(rhs.MinHeight);
            ret.MaxHeight = item.MaxHeight.EqualsWithin(rhs.MaxHeight);
            ret.Sink = item.Sink.EqualsWithin(rhs.Sink);
            ret.SinkVariance = item.SinkVariance.EqualsWithin(rhs.SinkVariance);
            ret.SizeVariance = item.SizeVariance.EqualsWithin(rhs.SizeVariance);
            ret.AngleVariance = item.AngleVariance.Equals(rhs.AngleVariance);
            ret.Unknown2 = MemoryExtensions.SequenceEqual(item.Unknown2.Span, rhs.Unknown2.Span);
        }
        
        public string ToString(
            IRegionObjectGetter item,
            string? name = null,
            RegionObject.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IRegionObjectGetter item,
            FileGeneration fg,
            string? name = null,
            RegionObject.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"RegionObject =>");
            }
            else
            {
                fg.AppendLine($"{name} (RegionObject) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IRegionObjectGetter item,
            FileGeneration fg,
            RegionObject.Mask<bool>? printMask = null)
        {
            if (printMask?.Object ?? true)
            {
                fg.AppendItem(item.Object.FormKey, "Object");
            }
            if (printMask?.ParentIndex ?? true)
            {
                fg.AppendItem(item.ParentIndex, "ParentIndex");
            }
            if (printMask?.Unknown ?? true)
            {
                fg.AppendItem(item.Unknown, "Unknown");
            }
            if (printMask?.Density ?? true)
            {
                fg.AppendItem(item.Density, "Density");
            }
            if (printMask?.Clustering ?? true)
            {
                fg.AppendItem(item.Clustering, "Clustering");
            }
            if (printMask?.MinSlope ?? true)
            {
                fg.AppendItem(item.MinSlope, "MinSlope");
            }
            if (printMask?.MaxSlope ?? true)
            {
                fg.AppendItem(item.MaxSlope, "MaxSlope");
            }
            if (printMask?.Flags ?? true)
            {
                fg.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.RadiusWrtPercent ?? true)
            {
                fg.AppendItem(item.RadiusWrtPercent, "RadiusWrtPercent");
            }
            if (printMask?.Radius ?? true)
            {
                fg.AppendItem(item.Radius, "Radius");
            }
            if (printMask?.MinHeight ?? true)
            {
                fg.AppendItem(item.MinHeight, "MinHeight");
            }
            if (printMask?.MaxHeight ?? true)
            {
                fg.AppendItem(item.MaxHeight, "MaxHeight");
            }
            if (printMask?.Sink ?? true)
            {
                fg.AppendItem(item.Sink, "Sink");
            }
            if (printMask?.SinkVariance ?? true)
            {
                fg.AppendItem(item.SinkVariance, "SinkVariance");
            }
            if (printMask?.SizeVariance ?? true)
            {
                fg.AppendItem(item.SizeVariance, "SizeVariance");
            }
            if (printMask?.AngleVariance ?? true)
            {
                fg.AppendItem(item.AngleVariance, "AngleVariance");
            }
            if (printMask?.Unknown2 ?? true)
            {
                fg.AppendLine($"Unknown2 => {SpanExt.ToHexString(item.Unknown2)}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IRegionObjectGetter? lhs,
            IRegionObjectGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (!lhs.Object.Equals(rhs.Object)) return false;
            if (lhs.ParentIndex != rhs.ParentIndex) return false;
            if (lhs.Unknown != rhs.Unknown) return false;
            if (!lhs.Density.EqualsWithin(rhs.Density)) return false;
            if (lhs.Clustering != rhs.Clustering) return false;
            if (lhs.MinSlope != rhs.MinSlope) return false;
            if (lhs.MaxSlope != rhs.MaxSlope) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.RadiusWrtPercent != rhs.RadiusWrtPercent) return false;
            if (lhs.Radius != rhs.Radius) return false;
            if (!lhs.MinHeight.EqualsWithin(rhs.MinHeight)) return false;
            if (!lhs.MaxHeight.EqualsWithin(rhs.MaxHeight)) return false;
            if (!lhs.Sink.EqualsWithin(rhs.Sink)) return false;
            if (!lhs.SinkVariance.EqualsWithin(rhs.SinkVariance)) return false;
            if (!lhs.SizeVariance.EqualsWithin(rhs.SizeVariance)) return false;
            if (!lhs.AngleVariance.Equals(rhs.AngleVariance)) return false;
            if (!MemoryExtensions.SequenceEqual(lhs.Unknown2.Span, rhs.Unknown2.Span)) return false;
            return true;
        }
        
        public virtual int GetHashCode(IRegionObjectGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Object);
            hash.Add(item.ParentIndex);
            hash.Add(item.Unknown);
            hash.Add(item.Density);
            hash.Add(item.Clustering);
            hash.Add(item.MinSlope);
            hash.Add(item.MaxSlope);
            hash.Add(item.Flags);
            hash.Add(item.RadiusWrtPercent);
            hash.Add(item.Radius);
            hash.Add(item.MinHeight);
            hash.Add(item.MaxHeight);
            hash.Add(item.Sink);
            hash.Add(item.SinkVariance);
            hash.Add(item.SizeVariance);
            hash.Add(item.AngleVariance);
            hash.Add(item.Unknown2);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return RegionObject.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<FormLinkInformation> GetContainedFormLinks(IRegionObjectGetter obj)
        {
            yield return FormLinkInformation.Factory(obj.Object);
            yield break;
        }
        
        #endregion
        
    }
    public partial class RegionObjectSetterTranslationCommon
    {
        public static readonly RegionObjectSetterTranslationCommon Instance = new RegionObjectSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IRegionObject item,
            IRegionObjectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Object) ?? true))
            {
                item.Object = new FormLink<IRegionTargetGetter>(rhs.Object.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.ParentIndex) ?? true))
            {
                item.ParentIndex = rhs.ParentIndex;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Unknown) ?? true))
            {
                item.Unknown = rhs.Unknown;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Density) ?? true))
            {
                item.Density = rhs.Density;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Clustering) ?? true))
            {
                item.Clustering = rhs.Clustering;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.MinSlope) ?? true))
            {
                item.MinSlope = rhs.MinSlope;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.MaxSlope) ?? true))
            {
                item.MaxSlope = rhs.MaxSlope;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.RadiusWrtPercent) ?? true))
            {
                item.RadiusWrtPercent = rhs.RadiusWrtPercent;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Radius) ?? true))
            {
                item.Radius = rhs.Radius;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.MinHeight) ?? true))
            {
                item.MinHeight = rhs.MinHeight;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.MaxHeight) ?? true))
            {
                item.MaxHeight = rhs.MaxHeight;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Sink) ?? true))
            {
                item.Sink = rhs.Sink;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.SinkVariance) ?? true))
            {
                item.SinkVariance = rhs.SinkVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.SizeVariance) ?? true))
            {
                item.SizeVariance = rhs.SizeVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.AngleVariance) ?? true))
            {
                item.AngleVariance = rhs.AngleVariance;
            }
            if ((copyMask?.GetShouldTranslate((int)RegionObject_FieldIndex.Unknown2) ?? true))
            {
                item.Unknown2 = rhs.Unknown2.ToArray();
            }
        }
        
        #endregion
        
        public RegionObject DeepCopy(
            IRegionObjectGetter item,
            RegionObject.TranslationMask? copyMask = null)
        {
            RegionObject ret = (RegionObject)((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).GetNew();
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public RegionObject DeepCopy(
            IRegionObjectGetter item,
            out RegionObject.ErrorMask errorMask,
            RegionObject.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            RegionObject ret = (RegionObject)((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).GetNew();
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = RegionObject.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public RegionObject DeepCopy(
            IRegionObjectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            RegionObject ret = (RegionObject)((RegionObjectCommon)((IRegionObjectGetter)item).CommonInstance()!).GetNew();
            ((RegionObjectSetterTranslationCommon)((IRegionObjectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class RegionObject
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => RegionObject_Registration.Instance;
        public static RegionObject_Registration Registration => RegionObject_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => RegionObjectCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return RegionObjectSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => RegionObjectSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IRegionObjectGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IRegionObjectGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IRegionObjectGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class RegionObjectBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static RegionObjectBinaryWriteTranslation Instance = new RegionObjectBinaryWriteTranslation();

        public static void WriteEmbedded(
            IRegionObjectGetter item,
            MutagenWriter writer)
        {
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Object);
            writer.Write(item.ParentIndex);
            writer.Write(item.Unknown);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Density);
            writer.Write(item.Clustering);
            writer.Write(item.MinSlope);
            writer.Write(item.MaxSlope);
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<RegionObject.Flag>.Instance.Write(
                writer,
                item.Flags,
                length: 1);
            writer.Write(item.RadiusWrtPercent);
            writer.Write(item.Radius);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.MinHeight);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.MaxHeight);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Sink);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SinkVariance);
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.SizeVariance);
            Mutagen.Bethesda.Binary.P3UInt16BinaryTranslation.Instance.Write(
                writer: writer,
                item: item.AngleVariance);
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Unknown2);
        }

        public void Write(
            MutagenWriter writer,
            IRegionObjectGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            WriteEmbedded(
                item: item,
                writer: writer);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (IRegionObjectGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class RegionObjectBinaryCreateTranslation
    {
        public readonly static RegionObjectBinaryCreateTranslation Instance = new RegionObjectBinaryCreateTranslation();

        public static void FillBinaryStructs(
            IRegionObject item,
            MutagenFrame frame)
        {
            item.Object = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                frame: frame,
                defaultVal: FormKey.Null);
            item.ParentIndex = frame.ReadUInt16();
            item.Unknown = frame.ReadUInt16();
            item.Density = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Clustering = frame.ReadUInt8();
            item.MinSlope = frame.ReadUInt8();
            item.MaxSlope = frame.ReadUInt8();
            item.Flags = EnumBinaryTranslation<RegionObject.Flag>.Instance.Parse(frame: frame.SpawnWithLength(1));
            item.RadiusWrtPercent = frame.ReadUInt16();
            item.Radius = frame.ReadUInt16();
            item.MinHeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.MaxHeight = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.Sink = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SinkVariance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.SizeVariance = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame);
            item.AngleVariance = Mutagen.Bethesda.Binary.P3UInt16BinaryTranslation.Instance.Parse(frame: frame);
            item.Unknown2 = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(6));
        }

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class RegionObjectBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IRegionObjectGetter item,
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionObjectBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class RegionObjectBinaryOverlay :
        BinaryOverlay,
        IRegionObjectGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => RegionObject_Registration.Instance;
        public static RegionObject_Registration Registration => RegionObject_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => RegionObjectCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => RegionObjectSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IRegionObjectGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IRegionObjectGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IRegionObjectGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        public IEnumerable<FormLinkInformation> ContainedFormLinks => RegionObjectCommon.Instance.GetContainedFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => RegionObjectBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((RegionObjectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public FormLink<IRegionTargetGetter> Object => new FormLink<IRegionTargetGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(_data.Span.Slice(0x0, 0x4))));
        public UInt16 ParentIndex => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x4, 0x2));
        public UInt16 Unknown => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x6, 0x2));
        public Single Density => _data.Slice(0x8, 0x4).Float();
        public Byte Clustering => _data.Span[0xC];
        public Byte MinSlope => _data.Span[0xD];
        public Byte MaxSlope => _data.Span[0xE];
        public RegionObject.Flag Flags => (RegionObject.Flag)_data.Span.Slice(0xF, 0x1)[0];
        public UInt16 RadiusWrtPercent => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x10, 0x2));
        public UInt16 Radius => BinaryPrimitives.ReadUInt16LittleEndian(_data.Slice(0x12, 0x2));
        public Single MinHeight => _data.Slice(0x14, 0x4).Float();
        public Single MaxHeight => _data.Slice(0x18, 0x4).Float();
        public Single Sink => _data.Slice(0x1C, 0x4).Float();
        public Single SinkVariance => _data.Slice(0x20, 0x4).Float();
        public Single SizeVariance => _data.Slice(0x24, 0x4).Float();
        public P3UInt16 AngleVariance => P3UInt16BinaryTranslation.Read(_data.Slice(0x28, 0x6));
        public ReadOnlyMemorySlice<Byte> Unknown2 => _data.Span.Slice(0x2E, 0x6).ToArray();
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected RegionObjectBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static RegionObjectBinaryOverlay RegionObjectFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new RegionObjectBinaryOverlay(
                bytes: stream.RemainingMemory.Slice(0, 0x34),
                package: package);
            int offset = stream.Position;
            stream.Position += 0x34;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static RegionObjectBinaryOverlay RegionObjectFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return RegionObjectFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            RegionObjectMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is IRegionObjectGetter rhs)) return false;
            return ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(IRegionObjectGetter? obj)
        {
            return ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((RegionObjectCommon)((IRegionObjectGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

